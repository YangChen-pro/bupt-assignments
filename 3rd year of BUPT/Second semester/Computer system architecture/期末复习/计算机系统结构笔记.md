### 第1章 基本概念

#### 计算机系统的层次结构：

计算机是由硬件、软件、固件（固化的微程序）组成的复杂系统，按机器语言功能划分为多级层次结构。

下面两级（微程序级、传统机器语言机器级）使用硬件/固件实现，称为**物理机**。上面四级由软件实现，称为**虚拟机**。第二级（传统机器语言级）是软硬件界面。

| 层数 | 语言             | 实现                                                   |
| :--- | :--------------- | :----------------------------------------------------- |
| 0    | 布尔语言（硬件） |                                                        |
| 1    | 微程序指令       | 用微指令集编写微程序，固件、硬件来解释                 |
| 2    | 传统机器语言     | 传统机器语言程序有 L1 级微程序或 L0 级硬联逻辑进行解释 |
| 3    | 操作系统         | 包括传统机器及操作系统级指令，由微程序解释             |
| 4    | 汇编语言         | 翻译成 L3 和 L2 级语言执行                             |
| 5    | 高级语言         | 通过编译程序翻译到 L4 或 L3 级，或通过解释方法实现     |
| 6    | 应用语言         | 由应用程序包翻译到 L5                                  |

#### 计算机系统结构的定义：

- **计算机系统结构**是指**传统机器语言程序员**所看到的计算机属性，即**概念性结构**、**功能特性**。
- 计算机系统结构的实质：**确定计算机系统中软硬件的界面**，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。
- **透明性**：一种本来存在的事物或属性，从某种角度看好像不存在或看不到。低层机器的属性对高层机器程序员来说通常是透明的。
- **广义系统结构定义**：包括指令系统结构、组成、硬件。

#### 计算机系统分类方法：

Flynn 分类法：按照指令流和数据流的多倍性分类。

* **分为 SISD（传统顺序处理计算机）、SIMD（阵列处理机）、MISD（流水处理机，有争议）、MIMD（多处理机）系统。**

冯氏分类法：用最大并行度$P_m$（单位时间内能够处理的最大二进制位数）分类。

Handler 分类法：把硬件结构分为三个层次，根据并行度和流水线分类。

* $T=<k×k',d×d',w×w'>$，其中

  $k$：控制器数目，$k'$：控制器流水线中控制部件的数目

  $d$：PCU 控制的 ALU 或 PE 数目，$d'$：指令流水线中 ALU 部件的数目

  $w$：ALU 或 PE 的字长，$w'$：操作流水线中基本逻辑线路数目

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101726943.png" alt="img" style="zoom:50%;" />

#### 4个定量原理

**大概率事件优先原理**： 优先加速使用频率高的部件。是**最重要和最广泛采用的计算机设计准则**。

**Amdahl 定律**：加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占总执行时间的百分比。

* $加速比 = \frac{系统性能_{改进后}}{系统性能_{改进前}} = \frac{总执行时间_{改进前}}{总执行时间_{改进后}}$
* $S_n = \frac{T_0}{T_n}=\frac{1}{(1-F_e)+\frac{F_e}{S_e}}$，$F_e$为可改进比例，$S_e$为部件加速比。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101736001.png" alt="img" style="zoom: 50%;" />

---

![img](https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101738316.png)

==作业题==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101804699.png" alt="image-20240610180453571" style="zoom:80%;" />

**CPU性能公式**

*CPI是每条指令执行的平均时钟周期数*

1. $t_{cpu}=IC \times CPI \times t$，其中$IC$是总指令数目，$t = \frac{1}{f}$是时钟周期时间
   * 也可以写成$t_{cpu} = \sum (CPI_i \times IC_i)$

2. 计算$CPI$

   $CPI = \frac{时钟周期数目}{IC} = \sum (CPI_i \times \frac{I_i}{IC}) $，每种指令的$CPI$与其占比相乘，再求和。

3. 计算$MIPS$，平均每秒执行多少百万条指令

   $MIPS = \frac{IC}{t_{cpu} \times 10^6} = \frac{f}{CPI \times 10^6}$

4. 计算$IC$，总指令数目

   $IC = \sum (CPI_i \times I_i)$，其中$I_i$表示指令$i$在程序中执行的次数

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101751260.png" alt="img" style="zoom:50%;" />

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101752693.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101753171.png" alt="img" style="zoom:50%;" />

==作业题==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101801679.png" alt="image-20240610180109610" style="zoom: 80%;" />

*但是答案（3）的单位有问题*

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406101802069.png" alt="image-20240610180254002" style="zoom:80%;" />

**局部性原理**

- **时间局部性：程序即将用到的信息很可能就是目前正在使用的信息。**（经验规则：程序执行时间 90%都是在执行程序中 10%的代码）
- 空间局部性：程序即将用到的信息很可能与正在使用的信息在空间上临近。

#### 系统结构设计

- “由上往下”设计，专用机设计
- “由下往上”设计，早期采用，易造成软件硬件脱节
- “由中间开始”设计：从传统机器级与操作系统机器级开始。

<img src="C:\Users\Administrator\Documents\WeChat Files\wxid_1kko67bpltlm22\FileStorage\Temp\de4ed2f21c8d10c3b4149da5ad0a2f7.jpg" alt="de4ed2f21c8d10c3b4149da5ad0a2f7" style="zoom:33%;" />

#### 系统的性能评测

总时间 = CPU 时间 + I/O 时间 + 运行其他程序的时间

CPU 时间 = 用户 CPU 时间 + 系统 CPU 时间

评价方法：CPU 时间、CPI、MIPS、MFLOPS。

**吞吐率**：在单位时间内流水线所完成的任务数量或输出结果的数量

#### 计算机系统结构的发展

**向上（下）兼容**：按某档机器编制的程序，不加修改就能运行于比它高（低）档的机器。

**向前（后）兼容**：按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之前（后）投入市场的机器。

==*向后兼容是系列机的根本特征*==

**模拟**：用软件的方法在一台现有的机器（称为宿主机）上实现另一台机器（称为虚拟机）的指令集。

**仿真**：用一台现有机器（宿主机）上的微程序去解释实现另一台机器（目标机）的指令集。

存储程序原理的基本点：指令驱动

冯诺依曼结构的主要特点：运算器为中心，指令和数据一样可以进行运算

#### 并行性的发展

**并行性**：计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作。

- 同时性：两个或两个以上的事件在同一时刻发生。
- 并发性：两个或两个以上的事件在同一时间间隔内发生。

**紧密耦合（直接耦合）**系统：通过**总线或高速**开关互连，可以共享主存

**松散耦合（间接耦合）**系统：通过通道或**通信线路**实现计算机之间的互连



### 第3章 流水线技术

#### 基本概念

流水线技术**主要思想**：把**一个复杂任务分解为若干个子任务**。每个子任务由专门功能部件完成，并使多个子任务并行执行。

流水线技术的**核心**：**部件功能专用化**。

流水线的级：流水线中每个子过程及其功能部件，称为一个流水段。流水线的段数称为**流水线深度**（长度）。

流水线的分类 1：

- **部件级**流水线（运算操作流水线）：各类型的运算操作按流水方式进行。
- **处理机级**流水线（指令流水线）：把一条指令的执行过程分段，按流水方式执行。
- **系统级**流水线（宏流水线）：把多台处理机串行连接起来，每个处理机完成整个任务中的一部分。

流水线的分类 2：

- 单功能流水线：只能完成固定功能。
- 多功能流水线：流水线的各段可以进行不同连接，实现不同功能。

流水线的分类 3：

- **静态**流水线：同一时间内，多功能流水线中的各段**只能按同一种功能的连接方式**进行工作。

- **动态**流水线：**同一时间内，多功能流水线中的各段可以按照不同方式连接，同时执行多种功能。**（而不需等到排空之后重新装入）

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102035561.jpg" alt="006d30d8c3c1eab682f898510873906" style="zoom: 33%;" />

流水线的分类 4：

- **线性流水线：流水线各段串行连接，每个段最多流过一次。**

- 非线性流水线：流水线中有反馈回路，每个段可以流过多次。

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102036503.jpg" alt="8dbf1a5d93fb7446f60db6a5bba2e5f" style="zoom: 33%;" />

流水线的分类 5：

- 顺序流水线：流水线输出的任务顺序与输入的任务顺序相同。
- 乱序流水线：流水线输出的任务顺序与输入的顺序**可以不同**。（也称无序、错序、异步流水线）

流水线通过时间和排空时间：

- **通过时间**：第一个任务**从**进入流水线**到**流出结果所需的时间，又称装入时间

- **排空时间**：最后一个任务从进入流水线到流出结果所需的时间

  在装入和排空的过程中，流水线不满载。

指令通过流水线时间最长的段称为**流水线瓶颈**。

每段流水线后面有一个缓冲寄存器，称为**流水寄存器**。有**缓冲、隔离、同步**作用。

#### 流水线的性能指标

**吞吐率 $TP$：单位时间内流水线完成的任务数量或输出结果的数量**

$TP=\frac{n}{T_k}$，$n$：任务数、$T_k$​：处理完成n个任务用时

**加速比 $S$：完成同样任务，不使用流水线所用时间与使用流水线所用时间之比。**

$S=\frac{T_s}{T_k}$，${T_s}$不用流水线用时，${T_k}$​用流水线用时

**效率 E：流水线中的设备实际使用时间与整个运行时间的比值，又称流水线设备利用率。**

| 分类                                          | k段流水线，完成n个任务用时（$\Delta t$是单位时间）           | 实际吞吐率                                                   | 最大吞吐率（$\lim_{n \to \infty}$）                      | 加速比                                                       | 最大加速比（$\lim_{n \to \infty}$） | 流水线的效率                                                 | 最高效率（$\lim_{n \to \infty}$） |
| :-------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------- | :----------------------------------------------------------- | :-------------------------------- |
| 各段时间**相等**                              | $T_k = (k + n - 1)\Delta t$                                  | $TP = \frac{n}{(k+n-1)\Delta t}$                             | $TP_{max}=\frac{1}{\Delta t}$                            | $S = \frac{nk}{n+k-1}$                                       | $S_{max}=k$                         | 各段效率$e_i$相同，$e_i = \frac{n \Delta t}{k} = \frac{n}{n+k-1}$，整条流水线效率$E = \frac{e_1+...+e_k}{k}=\frac{n}{k+n-1}$ | $E_{max}=1$                       |
| 各段时间**不等**，$\Delta t_i$是第$i$段的时间 | $T_k = {\sum_{i=1}^{k} \Delta t_i + (n-1)*\max(\Delta t_1, ..., \Delta t_k)}$ | $TP = \frac{n}{\sum_{i=1}^{k} \Delta t_i + (n-1)*\max(\Delta t_1, ..., \Delta t_k)}$ | $TP_{max} = \frac{1}{\max(\Delta t_1, ..., \Delta t_k)}$ | $S = \frac{n \sum_{i=1}^{k}\Delta t_i}{\sum_{i=1}^{k} \Delta t_i + (n-1)*\max(\Delta t_1, ..., \Delta t_k)}$ |                                     | $E=\frac{n \sum_{i=1}^{k}\Delta t_i}{k[\sum_{i=1}^{k} \Delta t_i + (n-1)*\max(\Delta t_1, ..., \Delta t_k)]}$ |                                   |

==$TP$、$S$、$E$关系：$E=TP \times \frac{\sum_{i=1}^k \Delta t_i}{k}$、$E = \frac{S}{k}$==

时空图上看，效率就是n个任务**实际占用**的时空面积和k段**总**的时空面积之比



<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102112449.jpg" alt="3f2b04c0c185aafc047ce0e4d05cd33" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102114202.jpg" alt="a3fbeac82a7e6a76b0fa84f6b4a53fe" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102114367.jpg" alt="a1b43c40144ed36e80e3261fa27ec3b" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102114499.jpg" alt="6680db9224b31784a405781924c1555" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102115648.jpg" alt="c2c0d13be36a54cb613be3b48c385c0" style="zoom:50%;" />

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102118969.jpg" alt="2064d1d18bc4f6b67f927b8c0b1b2c2" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102118778.jpg" alt="ffb19d688b0fbe9cf7b548ad6a9c61b" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102118540.jpg" alt="d48c33ce3942ffbbb318cc7a7566b3b" style="zoom:50%;" />

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102138963.png" alt="img" style="zoom:50%;" />

5次$x * y$，5次$(x*y)*z$

$x_1y_1z_1 + x_2y_2z_2$，$x_3y_3z_3+x_4y_4z_4$

$(x_1y_1z_1 + x_2y_2z_2) + x_5y_5z_5$

$((x_1y_1z_1 + x_2y_2z_2) + x_5y_5z_5) + (x_3y_3z_3+x_4y_4z_4)$

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102138069.png" alt="img" style="zoom:50%;" />

==作业题==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406112015450.png" alt="image-20240611201546357" style="zoom: 80%;" />



<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102121164.png" alt="image-20240610212125081" style="zoom: 67%;" />



<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406102121138.png" alt="image-20240610212133041" style="zoom: 67%;" />

解决流水线瓶颈的方法：

- 重复设置瓶颈段：让多个瓶颈流水段并行工作。
- 瓶颈段再细分：细分为多个子流水段（每个子流水段用时和非瓶颈段相同），形成超流水线。

#### 流水线相关与冲突（五段流水线）

经典五段流水线：分为 IF、ID、EX、MEM、WB 五个周期。

- IF：以程序计数器 PC 中的内容作为地址，从存储器中**取出指令**并放入指令寄存器 IR。PC 指向顺序的下一条指令。
- ID：指令译码，用 IR 中的寄存器地址去访问通用寄存器组，**读出所需操作数。**
- EX：
  - `load` 和 `store` 指令：ALU 把指定寄存器的内容与偏移量相加，形成访存有效地址。
  - ALU 指令：ALU 对从通用寄存器组读出的数据进行运算。
  - 分支指令：ALU 把偏移量与 PC 值相加，形成转移目标的地址。同时，**判断分支是否成功**。
- MEM：
  - `load` 和 `store` 指令：根据有效地址从存储器读出相应数据，或把指定数据写入有效地址指向的存储单元。（故，`store`只需要4个周期就能完成）
  - 分支指令：如果分支成功，就把在前一个周期中计算好的**转移目标地址送入 PC**。**分支指令执行完成（分支没有WB）**。否则，不进行任何操作。
  - **其他指令此周期不进行操作。**
- WB：把结果**写入通用寄存器组**。对于 ALU 指令，结果来自 ALU。对于 load 指令，结果来自存储器。

==避免IF段访存和MEM访存冲突==：读写冲突

==ID段和WB段都要访问同一寄存器文件==：ID读；WB写

**注意事项**：

- 默认写操作在前半拍，读操作在后半拍。
- 如果是**单周期延迟分支**，则分支指令在 ID 段完成计算目标地址和判断分支是否成功。（详见后面分支预测部分）

##### 相关

定义：2条指令之间存在某种依赖关系，不能重叠执行（或只能部分重叠）

类型：数据相关（真相关）、名相关、控制相关

* **数据相关**：下述条件**之一**成立，则称指令 i 和指令 j 之间数据相关。

  - 指令 j 使用指令 i 产生的结果。
  - 指令 j 与指令 k 数据相关，而指令 k 与指令 i 数据相关。（传递性）

* **名相关**：名指指令访问的寄存器或存储器的名称。两条指令使用了相同的名，但并没有数据流动关系，则称为名相关。

  * 反相关：指令 j 写的名 = 指令 i 读的名
  * 输出相关：指令 j 写的名 = 指令 i 写的名

  名相关的两条指令之间没有数据的传送，只是恰巧用了相同的名。可以通过**换名技术**（改变指令中操作数的名）消除名相关。对于寄存器操作数换名称为**寄存器换名**。寄存器换名既可以通过编译器静态实现，也可以硬件动态完成。

* **控制相关**：分支指令和其它*会改变 PC 值的指令*引起的相关。需要根据分支指令的执行结果来确定后面该执行哪个分支上的指令。

##### 冲突

定义：由于相关的存在，指令流中的下一条指令不能在指定的时钟周期开始执行

类型：结构冲突、数据冲突、控制冲突。

* **结构冲突**：因硬件资源满足不了指令重叠执行的要求而发生的冲突

  **解决方法**：插入暂停周期，或增加 Cache 等硬件资源。

* **数据冲突**：当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突。

  - *写后读*冲突（`RAW`、`WR`）：对应真数据相关。
  - *写后写*冲突（`WAW`、`WW`）：对应输出相关。写后写冲突仅发生在“*不止一个段可以进行写操作，或指令被重新排序*”的流水线中。前述五段流水线不发生 `WAW `冲突。
  - *读后写*冲突（`WAR`、`RW`）：对应反相关。读后写冲突仅发生在“*有些指令的写结果操作被提前、有些指令的读操作被滞后，或指令被重新排序*”的流水线中。前述五段流水线不发生 WAR 冲突。

  **解决方法**：

  * 使用**定向技术**（旁路技术）减少数据冲突引起的停顿：将计算结果从其产生的地方（ALU 出口）直接送到其他指令需要它的地方（ALU 的入口），可以避免停顿。
  * 使用**停顿**，例如 `LD` 后接一个算术指令
  * 依靠**编译器**解决数据冲突：在编译时让编译器重新组织指令顺序来消除冲突。称为**指令调度**或**流水线调度**。

* **控制冲突**：流水线遇到分支指令和其他会改变PC值的指令所引起的冲突。

  **解决方法**：

  * “冻结”“**排空**”流水线，在 ID 段检测到分支指令时，立即暂停流水线输入，进行 EX、MEM，确定是否分支成功并计算出新的 PC 值（因为在MEM才会写回PC的值），这样带来 **3 个时钟周期**的延迟。

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406111737014.jpg" alt="6c0cb7604e453262e1752676ca11073" style="zoom:50%;" />

  * **预测分支**：① 尽早判断出（或猜测）分支转移是否成功。② 尽早计算出分支目标地址。

    ==假设ID段就完成了上述2步工作==

    1. 预测失败，效果如下

       <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406111742211.jpg" alt="c13c57ff8e7a1b2dca87e660966fc33" style="zoom: 33%;" />

    2. 预测成功，没用。除非已知分支目标地址。

  * **延迟**分支，把无论是否分支成功都必须执行的指令，紧接着分支指令执行（放入延迟槽），延迟槽中的指令替换了原本必须插入的暂停周期。绝大多数延迟槽仅容纳一条指令。

     * 从前调度：从分支指令之前找一条指令插入延迟槽。被调度的指令必须与分支无关，适合任何情况。

     * 从目标处调度：分支成功时起作用。分支成功概率高时采用。

     * 从失败处调度：分支失败时起作用。不能从前调度时可用。

       <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406111958392.jpg" alt="4d9063712dd06c0635b9b44a99c0ac6" style="zoom:33%;" />

==作业题==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406112035861.png" alt="img" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406112035909.png" alt="img" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406112035830.png" alt="img" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406112035930.png" alt="img" style="zoom: 50%;" />

解析：

（1）只有 WB 到 ID 的定向（通用寄存器定向，WB 和 ID 可在同一时间）。例如 3、4 周期，停顿等待 WB 段写回寄存器，5 周期定向。而遇到分支指令时，需要排空流水线（3周期延迟），所以 15 周期 ID 段检测到分支指令就暂停下个指令的取指。15-17 周期，等待 MEM 写回 PC，18 周期才能取指。

（2）有定向之后，ID 与 EX 在同一时间，但执行 EX 前可能仍然需要等。这道题是 3 周期延迟分支，所以预测分支失败（实际分支是成功）会有 3 个周期的延迟。

（3）单周期延迟分支加上指令调度，就不会有延迟。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121148026.png" alt="image-20240611214454549" style="zoom: 80%;" />

解析：

（1）无条件，需要等到上一条指令的周期2结束，才能开始（1停顿）；有条件，需要等到上一条指令的周期3结束，才能开始（2停顿）

（2）预测成功，首先需要得到成功的地址，在上一条指令的周期2结束才能得到，此时，所有分支必然都有1个停顿；对于无条件和成功的条件跳转（预测成功且成功），就是这1个停顿；对于失败的条件跳转（预测成功但实际失败），需要等到上一条指令的周期3结束，才能得到正确的PC，共计2停顿

（3）预测失败，对于失败的条件分支，无需等待；对于成功的跳转，即无条件跳转和成功的条件分支，需要得到它们正确的PC，分别是1停顿和2停顿。

==归纳==

**减少数据冲突的方法：延迟、定向、编译**

**解决控制冲突的方法：排空、预测、延迟分支、编译**

### 第4章 向量处理机

#### 向量基本概念和处理方法

向量处理机：设置了向量数据表示和向量指令的流水线处理机。

向量处理机方式：

- **横向处理方式**：向量按 column 的方式从左到右横向进行。适用于一般处理机，不适用于向量处理机的并行处理。
- **纵向处理方式**：向量按 row 的方式从上到下纵向进行。将整个向量按相同运算处理完之后，再进行别的运算。不产生数据相关，对向量长度 N 没有限制。
- **纵横处理方式**：把向量分成若干组，组内按纵向方式处理，依次处理各组。对向量长度 N 没有限制，但以每 n 个元素分一组处理，n 的值固定。

#### 向量处理机的结构

**存储器-存储器**结构：适合**纵向**处理方式。

**寄存器-寄存器**结构（如CRAY-1）：适合**纵横**处理方式。

*CRAY-1有4组12个单功能流水部件。只要不出现**V~i~冲突**和**功能部件冲突**，就能并行（此处是指并行，不是后文的链接）处理*。

* **V~i~冲突**：**源向量**或**结果向量**相同
* **功能部件冲突**：使用同一种功能部件（如，都用加法）

#### 提升性能的技术

- 设置多个功能部件并行
- 链接技术：向量运算输出可直接作为输入使用，结果寄存器立即成为后继指令操作数寄存器。是定向技术的发展，利用 RAW 数据相关性。**数据进（出）每个功能部件需 1 个时钟周期。**
- 分段（循环）开采：向量长度大于向量寄存器长度时，对向量进行分段处理，系统完成，对程序员**透明**。
- 多处理机

#### 链接

当**前一条指令的结果寄存器**是**后一条指令的源寄存器**、**且不存在其他任何冲突时**，就可以用链接技术来提高性能。

表现为，**先写后读相关**的两条指令，在**没有功能部件冲突**和**源向量冲突**的情况下，可以把功能部件链接起来，进行流水处理，加快执行。

==向量数据送到向量功能部件，结果存入向量寄存器，都需要一拍时间==

==从存储器中把数据送入访存功能部件，也需要一拍时间==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121148453.jpg" alt="657e9a0d29d77e28b9e3cec926cdcf8" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121148392.jpg" alt="5dd727365ac518ca415569a8da66dd3" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121148410.jpg" alt="569736fcaa564ea446e5f89907ea191" style="zoom:50%;" />

在向量长度为64的前提下，共计需要 24 + 64 - 1= 87(拍)

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121157082.jpg" alt="407082a053c92fe3ece3caeb690d6f5" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121158698.jpg" alt="0d2b9edeb57d386b35259bc309442b8" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121158329.jpg" alt="709d2af9f74a3af8b6ecea09fb00946" style="zoom:50%;" />

---

**链接的4个条件**

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121158918.jpg" alt="d37c31bd38a90cc35bbfad32afdfeba" style="zoom:50%;" />

==作业题==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121202746.png" alt="image-20240612120220644" style="zoom: 80%;" />

**分段开采技术**：当向量的长度大于向量寄存器的长度时，必须把长向量分成长度固定的段，然后循环分段处理，每一次循环只处理一个向量段。

#### 向量处理机的性能评价

**一条向量指令的处理时间**：$T_{vp}=T_s+T_e+(n-1)T_c$，$T_s$建立时间，$T_e$通过流水线的时间，$T_e$时钟周期的单位时间

换为始终周期数，有$T_{vp}=[s+e+(n-1)]T_c$，$s$是$T_s$对应的周期数量，$e$是$T_e$对应的周期数量

若不考虑$T_s$，并令$T_{start}=e-1$，有==$T_{vp}=(T_{start} + n)T_c$==

$T_{start}$ 为**从第一条指令开始执行，到还差一个时钟周期就产生第一个结果**所需时钟周期数

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121549131.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121549232.png" alt="img" style="zoom:50%;" />

此处的$l$是上文公式的$e$，代表通过流水线的周期数量（也就是流水线的段数）

**一组向量指令的总执行时间**：$T_{all}=\sum_{i=1}^{m}T_{vp}^{(i)}$，$T_{vp}^{(i)}$是第$i$个编队的时间，$m$是编队个数

一个编队有若干指令，令$T_{start}^{(i)}$是第$i$编队中，各指令启动时间的最大值

$T_{all} = \sum_{i=1}^{m}(T_{start}^{(i)}+n)T_c = (T_{start}+mn)T_c$，其中$T_{start}=\sum_{i=1}^{m}T_{start}^{(i)}$，$n$是向量长度。

换为时钟周期数，有==$T_{all}=T_{start}+mn$==，单位（拍）

**分段开采时，总执行时间**：==$T_{all}=\lceil {\frac{n}{MVL} }\rceil \times (T_{start}+T_{loop}) + mn$==，其中$MVL$为向量寄存器长度，$m,n,T_{start}$定义同上，$T_{loop}$为循环所引入的额外时间

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121605609.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121605695.png" alt="img" style="zoom:50%;" />

***在链接的时候，编队的含义就不是并行了，而是编队内的指令可以连接（队内$T_{start}直接相加）$。***

==作业题==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121609870.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121610549.png" alt="img" style="zoom:50%;" />

==链接执行（两个编队，`LV` 和 `SV` 部件冲突）：$T=4×(15+31)+2×200=584$==

**向量流水线最大性能** $R_{\infty} = \lim_{n \to \infty} \frac{向量指令序列中浮点运算次数 \times 时钟频率}{向量指令序列执行所需时钟周期数}$

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121616638.png" alt="img" style="zoom:50%;" />

**半性能向量长度 $n_{1/2}$** ：向量处理机性能为其$ R_{\infty}$ 一半时所需向量长度。与流水线建立时间有关。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121621344.png" alt="img" style="zoom:50%;" />

**向量长度临界值$n_v$** ：向量流水方式的处理速度优于标量串行方式的处理速度时，向量长度的临界值。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121623809.png" alt="img" style="zoom:50%;" />

之前算出来$\lceil {\frac{n}{64}} \rceil \times 64 + 3n$，其中$n$不会很大，故$\lceil \frac{n}{64} \rceil\approx 1$

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406121623259.png" alt="img" style="zoom:50%;" />



### 第5章 指令级并行——硬件

#### 指令级并行的概念

对于正确执行的程序来说，必须保持的最关键的两个属性是：**数据流和异常行为**

* **保持异常行为**：无论怎么改变指令执行的顺序，都不能改变程序中异常的发生情况（不能有新的异常）
* **数据流**：指数据值从其产生者指令到其消费者指令的实际流动

**静态调度**：依靠**编译器**对代码进行静态调度，以减少相关和冲突。在编译期间，把相关的指令拉开距离来减少可能产生的停顿。

**动态调度**：能在**保持数据流和异常行为**的情况下，通过**硬件**对指令执行的顺序进行重排，减少数据相关导致的停顿：

#### 动态调度算法（记分牌，Tomasulo）

将5段流水线的**译码阶段**，再细分

1. **流出（IS）**：指令译码，检查是否存在结构冲突
2. **读操作数（RO）**：等待数据冲突消失，然后读操作数

但，这会引入乱序执行，进而引入`WAR`和`WAW`冲突

**不精确异常**：当执行指令 i 导致发生异常时，处理机的现场（状态）与严格按照程序顺序执行时指令 i 的现场不同

**精确异常**：发生异常时，处理机的现场跟严格按照程序顺序执行时指令 i 的现场相同

#### 记分牌算法

**记分牌的目标**：在没有结构冲突时，尽早执行没有数据冲突的指令。

指令执行的**步骤**：每条指令的执行过程分为 4 段——**IS 流出、RO 读操作数、EX 执行、WB 写结果**。（主要考虑浮点操作，运算在浮点寄存器之间进行，不涉及 MEM 段）

- **流出**：若流出指令所需的功能部件空闲，并且所有其他执行中的指令的目的寄存器与该指令不同，记分牌就向功能部件流出该指令，并修改记分牌内部的记录表。如果存在结构相关或 `WAW` 冲突，则该指令不流出。（**在流出段解决了` WAW` 冲突**）
- **读操作数**：记分牌检测源操作数的可用性。一旦数据可用，它就通知功能部件从寄存器中读出源操作数并开始执行。否则就等待写完成之后再读出（锁定）（**读操作数段动态地解决了 RAW 冲突，并可能导致指令乱序执行**）
- 执行：取到操作数后，功能部件开始执行。结果产生后，通知记分牌它已完成执行。这一步相当于五段流水线中的 EX。但在浮点流水线中，**这一段可能占用多个时钟周期**。其他指令如果不与**正在执行或被锁定**指令相关，可提前执行或完成。
- **写结果**：记分牌知道执行部件完成执行后，检测是否存在` WAR `冲突（前面某条指令的源操作数寄存器，是本指令的目标寄存器）。如果不存在（或已有的` WAR `冲突已消失），记分牌就通知功能部件把结果写入目的寄存器，并释放该指令执行所用的所有资源。否则必须等待。这一步对应五段流水线的 WB。

**记分牌记录信息**的组成：

- **指令状态表**：记录正在执行的各条指令已经进入哪一段。
- **功能部件状态表**：记录各个功能部件的状态。每个功能部件有 1 项，每项由 9 个字段组成。
  - $Busy$：忙标志，功能部件是否正忙。
  - $Op$：正在或将要执行的操作。
  - $F_i$：目的寄存器编号，$F_j$，$F_k$：源寄存器编号。（按指令中的顺序排列）
  - $Q_j$，$Q_k$：向源寄存器 $F_j$、$F_k$ 写数据的功能部件。
  - $R_j$，$R_k$：源寄存器标志位，“yes”表示 $F_j$、$F_k$  的操作数**可用——就绪且未被取走（产生且未读）**。否则“no”。
- **结果寄存器状态表**：每个寄存器在该表中有一项，用于指出哪个功能部件（编号）将把结果写入该寄存器。如果正运行的指令全都不以它为目的寄存器，则设置为“no”或 0。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122013834.jpg" alt="963c0dd60caef45c52e674b9492e29f" style="zoom:80%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122020780.png" alt="image-20240612202019634" style="zoom: 80%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122021991.jpg" alt="88baa52705e9733b5ae09e03921acb6" style="zoom:50%;" />

在`DIV.D`写结果前，`F6`引起的相关，操作数取走时，就已经消除了，所以`ADD.D`有充足的时间完成所有操作。

![8d1b0f74b5a18f41d2ef421233e5376](https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122022186.jpg)

==作业题==

给出`SUB.D`准备写结果之前的记分牌状态。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122026725.png" alt="image-20240612202646597" style="zoom: 80%;" />

总结规律：

* 在读操作数时，若卡住（需要的数，还没写好），==R列的"yes"和Q列互补==
* **资源冲突或`WAW`冲突**，在流出时，会被卡住（不能执行）
* **`WAR` 冲突**会导致记分牌在写结果阶段停顿（不能写，否则其他指令取错数字）

#### Tomasulo算法

**核心思想**

- **记录和检测指令相关，操作数一旦就绪就立即执行，把发生 RAW 冲突的可能性减到最小。**
- 通过**寄存器换名**技术**消除 `WAR`冲突和` WAW `冲突**。寄存器换名是通过保留站来实现，它保存等待流出和正在流出指令所需要的操作数。

==示例==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122046583.jpg" alt="cecaa6776c13ab80402a75076f76e84" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122046485.jpg" alt="4b93f21c50696cbb882a6f7f658c07c" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122046075.jpg" alt="d724511f95dfd2a7527d3076f0cf74c" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122046499.jpg" alt="cb54ebd9fa9c0db380acad1e9995397" style="zoom:50%;" />

**保留站字段**：

- $Op$：对源操作数进行的操作。
- $Q_j$，$Q_k$：将产生源操作数的保留站号。$0 $表示操作数已就绪且在$ V_j$，$V_k$中，或者不需要操作数。
- $V_j$，$V_k$：源操作数的值，如`Regs[F4]`。对于每一个操作数来说，$V $或 $Q$ 字段只有一个有效。
- $Busy$：“yes”表示本保留站或缓冲单元正忙。
- $A$​：仅 `load` 和` store` 缓冲器有该字段。**开始先存放指令中的立即数字段，地址计算后存放有效地址。**

*公共数据总线 CDB：重要的数据通路。所有计算结果都送到 CDB，它直接播送到各个需要的地方。多个执行部件且采用多流出的流水线中有多条 CDB。计算结果先送到 CDB 再传送到功能部件，不需要经过寄存器。*

**指令执行的步骤**：

- **流出**：从指令队列头部取指。如果该指令操作**所要求的的保留站有空闲**的，则把该指令送到该空闲保留站（设为 r）。**如果操作数未就绪，则进行寄存器换名**。另外，进行目的寄存器预约，将其设置为接收保留站 r 的结果（相当于提前完成了写操作）。由于指令顺序流出，同一个结果寄存器的预约结果肯定是最后一条指令的，消除了 WAW 冲突。如果没有空闲保留站，指令不能留出（发生结构冲突）。
- **执行**：如果某个操作数未被计算出来，保留站监视 CDB，结果产生保留站立刻从 CDB 获取数据。操作数都就绪后保留站用相应的功能部件开始执行指令操作。（靠推迟执行的方法解决 RAW 冲突）load 指令执行条件是存储器部件就绪，而 store 指令执行的条件是要存入存储器的数据到达并且存储器部件就绪。
- **写结果**：功能部件计算完毕后将结果放到 CDB 上，等待该结果的寄存器和保留站同时从 CDB 获取数据。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122053460.jpg" alt="23f8a6641b2b89d9254fb691efbdfc5" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122054590.jpg" alt="fca3bb489f9a871c4120937403266f1" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122054044.jpg" alt="1ad074f63d2c16d303d88c9bc36c452" style="zoom: 50%;" />

`Add1`中，$V_k$和$Q_j$​写错了，应该向两侧移动。

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122059809.jpg" alt="a90b315fcea144e76590fbac3aa3e35" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122059088.jpg" alt="838863b33a0756aa199d1007c6d2c4e" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122059607.jpg" alt="992846f19bf84d239be7f9352e8085f" style="zoom:50%;" />

这里，由于`ADD.D`指令与`DIV.D`指令的`WAR`冲突已经消除，`ADD.D`可以先于`DIV.D`完成并将结果写人F6，不会出现错误。

==作业题==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122110691.png" alt="image-20240612211005464" style="zoom: 67%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122110814.png" alt="image-20240612211047651" style="zoom: 80%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122111260.png" alt="image-20240612211122090" style="zoom: 67%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122111825.png" alt="image-20240612211148672" style="zoom:67%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122112239.png" alt="image-20240612211229059" style="zoom: 67%;" />

#### 动态分支预测技术

**目的**：① 预测分支是否成功。② 尽快找到分支目标地址或指令。

**需要解决的问题**：① 如何记录分支的历史信息。② 如何根据这些信息预测分支去向，甚至提前取出分支目标指令。

##### 分支历史表 BHT

记录分支指令最近几次的执行情况（成功或失败），并据此预测。使用两个 bit 存储历史分支信息。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122135495.png" alt="img" style="zoom: 33%;" />

BHT 两个步骤：

- 分支预测：当分支指令到达 ID 时，从 BHT 读出的信息进行分支预测。若正确就继续处理后续指令。若错误就作废预取指令，恢复现场，并从另一条分支路径重新取指。
- 状态修改：修改 BHT 状态。

##### 分支目标缓冲器 BTB

分支目标缓冲器 Branch-Target Buffer 作用：

- 将分支成功的分支指令的地址，和它的分支目标地址都放到一个缓冲区中保存。
- 缓冲区以分支指令的地址作为标识，得到转移目标指令地址信息。
- 在 IF 段访问 BTB，将分支的开销降为 0。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122140336.jpg" alt="694aca90756819b1ffe090016e8d9b6" style="zoom:33%;" />



（延迟两个周期：预测失败需要更新 BTB 的项，花费 1 个周期。对 BTB 项进行更改时需要停止取值，又花费 1 个周期）

##### 基于硬件的前瞻执行

基本思想：对分支结果预测，按预测结果继续取指、流出、执行后续指令，但结果不写回寄存区或存储器，而是写入**前瞻执行缓冲器 ROB**，等到指令“确认”之后再写回寄存器或存储器。

基于硬件的前瞻执行结合了 3 种思想：

- 动态分支预测。用来选择后续执行的指令。
- 在控制相关的结果尚未出来之前，前瞻地执行后续指令。
- 用动态调度对基本块的各种组合进行跨基本块的调度。

把 Tomasulo 算法的**写结果和指令完成**加以区分，分成两个不同的段：**写结果（写到ROB），指令确认（写到寄存器或存储器）**。

*允许指令乱序执行，但必须顺序确认*。在指令被确认之前，不允许它进行不可恢复的操作。

指令执行的步骤：

- **流出**：从浮点指令队列的头部取一条指令。如果有空闲的保留站（设为 r）**且有空闲的 ROB 项**（设为 b），就流出该指令，并把相应的信息放入保留站 r 和 ROB 项 b。如果保留站或 ROB 全满，便停止流出指令，直到它们都有空闲的项 。

- **执行**：如果有操作数尚未就绪，就等待，并不断地监测 CDB（检测 RAW 冲突）。当两个操作数**都已在保留站中就绪后**，就可以执行该指令的操作。

- **写结果**：当结果产生后，将该结果连同本指令在流出段所分配到的 ROB 项的编号放到 CDB 上，经 CDB **写到 ROB** 以及所有等待该结果的保留站。释放产生该结果的保留站。

  `store`指令在本阶段完成，其操作为：

  - 如果要写入存储器的数据已经就绪，就把该数据写入分配给该 store 指令的 ROB 项。
  - 否则，就监测 CDB，直到那个数据在 CDB 上播送出来，才将之写入分配给该 store 指令的 ROB 项。

- **确认**：对分支指令、store 指令以及其它指令的处理不同：

  - 其它指令（除分支指令和 store 指令）：当该指令到达 ROB 队列的头部而且其结果已经就绪时，就把该结果写入该指令的目的寄存器，并从 ROB 中删除该指令。
  - store 指令处理与上面的类似，只是它把结果写入存储器。
  - 分支指令：当**预测错误**的分支指令到达 ROB 队列的头部时，**清空 ROB**，并从分支指令的另一个分支重新开始执行。当预测正确的分支指令到达 ROB 队列的头部时，该指令执行完毕。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122155343.jpg" alt="457506cc0604fbe4f854788ac41b910" style="zoom:50%;" />



<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122156208.jpg" alt="20395a7d97f5b14c271cdd2c8b0c541" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122157870.jpg" alt="37e41f369831af0cb2244d63763d769" style="zoom:50%;" />

这时指令`SUB.D`尽管已经执行完毕，但需要等到`MUL.D`得到确认后才能确认。保留站和寄存器状态表与Tomasulo算法保存的信息类似，所不同的是$Q_i$和$Q_k$字段以及寄存器状态字段中**存放的是ROB项的编号**，而不是保留站的编号。而且在保留站中增加了`Dest`字段。这个Dest字段指出是**哪个ROB项将接收**该保留站产生的结果。

尽管`SUB.D`和`ADD.D`指令还没有确认（需要等`MUL.D`先确认），但结果已经产生，放在ROB中的`Value`字段，可以用作其他指令的源操作数。

#### 多指令流出技术

一个时钟周期内，流水线流出指令条数，称为 IPC。

在每个时钟周期内流出多条指令，CPI<1。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122202615.png" alt="img" style="zoom: 33%;" />

两种多流出处理机：

- **超标量**：
  - 每个时钟周期流出的指令条数**不固定**，但有上限 n。这种处理机称为 n 流出（n 发射）处理机。
  - 可以通过编译器静态调度，也可以基于 Tomasulo 算法进行动态调度。
- **超长指令字 VLIW**（Very Long Instruction Word）：
  - 单一的流或控制器：在每个周期流出指令条数**固定**，这些指令构成一个长指令（指令包），通常大于 100 位。
  - 指令包中的指令之间并行性通过指令显式地表示出来。
  - 大量的数据通路和功能部件：设置多个功能部件。
  - 超长指令字包含多个控制字段：指令字被分割成一些字段，每个字段称为一个**操作槽**，直接独立控制一个功能部件。
  - 超长指令字的生成由编译器完成：指令调度由编译器静态完成，流出时无需复杂冲突检测。

**超流水线处理机**：每 1/n 个时钟周期流出一条指令。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122214291.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122214276.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406122214350.png" alt="img" style="zoom:50%;" />



### 第9章 互连网络

#### 互连函数

循环表示法：$(x_0,x_1,x_2,\dots,x_{j-1})$，表示 $I(x_0,x_1,x_2,\dots,x_{j-1})=(x_1,x_2,x_3,\dots,x_{j-1}x_0)$，$j$ 称为循环长度。

基本互连函数：

- **恒等函数**：$I(x_{n-1}x_{n-2}\dots x_1x_0)=x_{n-1}x_{n-2}\dots x_1x_0$

- **交换函数**：用于构造**立方体和超立方体**互连网络。

  $Cube_k(x_{n-1}x_{n-2}\dots x_k \dots x_1x_0)=x_{n-1}x_{n-2}\dots \overline{x_k} \dots x_1x_0$。

  实现二进制地址编号中**第 k 位取反**（角标为$k$时）

  互连函数种类为 $n=\log_2{N}$，$N $为结点个数。

* **均匀洗牌函数**（也称混洗函数）：用于构造 Omega 和逆 Omega 网络。将入线均分，前一部分和后一部分按顺序一个接一个交叉连接。

  $\sigma(x_{n-1}x_{n-2}\dots x_1x_0) = x_{n-2}x_{n-3}\dots x_0x_{n-1}$，输入端的二进制**循环左移**

  * 第$k$个子函数$\sigma_{(k)}$，**低$k$位**循环左移
  * 第$k$个子函数$\sigma^{(k)}$，**高$k$位**循环左移

  逆均匀洗牌$\sigma^{-1}(x_{n-1}x_{n-2}\dots x_1x_0) = x_0x_{n}x_{n-1}\dots x_2x_1$​，循环右移。

* **蝶式函数**

  $\beta(x_{n-1}x_{n-2}\dots x_1x_0) = x_{0}x_{n-2}\dots x_1x_{n-1}$​，将输入端二进制**最高位与最低位互换**位置得到。

  * 第$k$个子函数$\beta_{(k)}$，**低$k$位**的最高位和最低位互换（$x_{k-1}$与$x_0$换）
  * 第$k$个子函数$\beta^{(k)}$，**高$k$位**的最高位和最低位互换（$x_{n-1}$与$x_{n-k}$换）

* **反位序函数**

  $\rho(x_{n-1}x_{n-2}\dots x_1x_0)=x_{0}x_{1}\dots x_{n-2}x_{n-1}$​，把输入二进制编号各位次序**颠倒**。

  * 第$k$个子函数$\rho_{(k)}$，**低$k$位**颠倒（$x_{k-1}\dots x_0$颠倒）
  * 第$k$个子函数$\rho^{(k)}$，**高$k$位**颠倒（$x_{n-1}\dots x_{n-k}$​颠倒）

* **移数函数**

  $\alpha(x)=(x\pm k) \mod N$

* **$PM2I$函数**：加减$2^i$，构成数据变换网络的基础。实质为 1、2、4 个环形网（如阵列计算机ILLIAC IV，采用$PM2_{\pm 0}$和$PM2_{\pm n/2}$）。

  $PM2_{+i}=(x+2^i) \mod N, 0 \le i \le \log_2N$

  $PM2_{-i}=(x-2^i) \mod N$

#### 结构参数与性能指标

6 个结构参数：

- **网络规模 N**
- **结点度 d**：结点所连接的边数。（入度、出度）
- 结点距离：从一个结点出发到另一个结点，经过边数的最小值。
- **网络直径 D**：网络中结点距离的最大值。（越小越好）
- **等分宽度 b**：把网络均分为结点数相同的两半，在各种切法中，沿切口边数的最小值。线等分宽度 B = b × w，w 为通道宽度（bit），等分宽度反映网络最大流量。
- **对称性**：从任意结点看，网络的结构都是相同的。

两类性能指标：时延和带宽

- 时延：
  - 通信时延：
    - 软件开销：源节点、目的结点收发消息软件的执行时间。取决于软件内核。
    - 通道时延：消息长度/通道带宽。通常由瓶颈段带宽决定。
    - 选路时延：与传送路径上结点数成正比。
    - 竞争时延：避免、解决争用所需的时间。很难预测，取决于网络状态。
  - **网络时延**：通道时延+选路时延。由网络硬件决定，与软件、传输状态无关。
- 带宽
  - 端口带宽：单位时间内从该端口传输到其他端口的最大信息量。
    - 对称网络中各端口带宽相等=网络端口带宽。
    - 非对称网络的端口带宽=所有端口带宽的最小值。
  - 聚集带宽：网络从一半节点到另一半节点，单位时间传送的最大信息量。
  - 等分带宽：与等分宽度对应的切平面中，所有边合起来，单位时间传送的最大信息量。

#### 静态互连网络

- **线性阵列**：一维线性网络，N 个结点用 N−1个链路连成一行。

  ![image-20240613150958118](https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131510323.png)

  端节点度为1，其余节点度为2；直径 N-1；等分宽度 b=1

- **环和带弦环**：用一条附加链路将线性阵列端结点连接，构成环。

  - 带弦环：增加链路越多，结点度越高，网络直径越小。

    ![image-20240613151107382](https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131511535.png)

    对称；节点度为2；单向环直径N，双向环直径 N/2；环等分宽度 b=2

  - 全连接网络：极端情况。

    ![image-20240613151231895](https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131512048.png)

    节点度15；直径最短，为1

- **循环移数网络**：在环上每个结点到所有**与其距离为 2 的整数幂**的结点之间都增加一条附加链路。

  ![image-20240613151332947](https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131513104.png)

  N=16；节点度7；直径2

  一般地，若$|j-i|=2^r(r=0,1,...n-1,n=\log_2N)$，则节点$i$与节点$j$相连

  ==节点度：2n-1；直径：$\lceil$ n/2 $\rceil$；网络规模 N=2^n^==

* 树形和星形

  树状：k 层完全平衡二叉树有 N=2^k^-1个结点。

  星形：CS 模式。中心结点故障，整个系统瘫痪。

  胖树形：越靠近树根，树干越粗（通道带宽增加）。

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131518098.png" alt="img" style="zoom: 33%;" />

  

- 网格形、Illiac、环状网络：

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131523653.png" alt="img" style="zoom: 33%;" />

- 超立方体：n 维结点数 N=2^n^。对于一个结点，在每一维方向上都只和一个结点相连。

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131523856.png" alt="img" style="zoom: 33%;" />

- 带环 n-立方体（n-CCC）：用 k 个结点构成的环代替 k 维超立方体。结点度恒定，扩展性好。

  <img src="https://static.xqmmcqs.com/2022-06-08-16-52-44-CKdUyi.png" alt="img" style="zoom: 33%;" />

- k 元 n-立方体网络：

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131523281.png" alt="img" style="zoom: 33%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406131523668.png" alt="img" style="zoom:50%;" />

#### 动态互连网络

由有源交换开关构成，链路可通过设置开关状态重构。网络边界上开关元件可与处理机相连。

总线结构

- 优点：结构简单、实现成本低。
- 缺点：模块分时共享，带宽较窄。（可采用多总线或多层次总线解决）

交叉开关网络

- 可以无阻塞实现 n! 种置换。

多级互联网络

- MIMD 和 SIMD 计算机都采用多级互连网络 MIN。

**区别**：开关模块、控制方式、级间互连模式不同。

- 2×2 开关模块：**直送、交叉、上播、下播。**
- **控制方式**：
  - 级控制：每一级的所有开关只用一个控制信号控制，只能同时处于同一种状态
  - 单元控制：每一个开关都有一个独立的控制信号，可各自处于不同的状态
  - 部分级控制：第 i 级的所有开关分别用 i+1 个信号控制，0 ≤ i ≤ n-1，n 为级数
- 级间互连：参考交换原理。

多级立方体网络：STARAN 网络、间接二进制 n 方体网络。都采用二功能（直送和交换）的 2×2 开关。**当第 i 级（0≤i≤n−1）交换开关处于交换状态时，实现的是 Cube~i~ 互联函数**。

一个$N$输入的多级立方体网络有$\log_2N$级，每级用$\frac{N}{2}$个$2 \times 2$个开关模块，共需要$\log_2N \times \frac{N}{2}$个开关。下图是一个8输入的多级立方体网络

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132048384.png" alt="img" style="zoom:50%;" />

*STARAN 网络采用级控制（实现交换功能）和部分级控制（实现移数功能），间接二进制 n 立方体网络采用单元控制。*

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132055120.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132055118.png" alt="img" style="zoom: 33%;" />

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132111799.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132111786.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132111837.png" alt="img" style="zoom:50%;" />

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132112213.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132112233.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132112303.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132112318.png" alt="img" style="zoom:50%;" />

Omega 网络：级间全部采用均匀洗牌。N=8 的多级立方体互连网络的另一种画法。

$N$ 个输入有 $\log_2 N$级，每级$\frac{N}{2}$个四功能的 2×2 开关模块，每个开关模块采用**单元控制方式**

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132115498.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406142102353.png" alt="img" style="zoom:67%;" />

![image-20240614210944368](https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406142109814.png)

（2）解析：置换连接是指网络的输入端与输出端的一对一连接，故只考虑 2×2 开关的 2 个功能状态，即直送与交叉。网络采用单元控制，因此，每个开关都根据连接要求处于 2 个功能状态中的一种状态。故，底数是2

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406142114771.png" alt="img" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406142114509.png" alt="img" style="zoom:50%;" />

#### 消息传递机制

消息：节点间通信的逻辑单位，由若干“包”组成。包的长度固定但是数量可变。

包是包含寻径所需目的地址的基本单位。包分为若干“片”，大小固定。

寻径信息和包序列号形成头片，其余是数据片。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132128857.jpg" alt="9a479e4e317d6289f27601bb96bf86b" style="zoom: 33%;" />

**两类四种寻径方式**

- 线路交换：建立物理通路再传递信息。时延$T=\frac{L+L_t \times (D+1)}{B}$，$L$为包总长，$L_t$为建立路径所需最小包长度，$D$为中间结点个数，$B$为带宽。

  - 优点：带宽大，平均时延小，占用缓冲区小。
  - 适合动态和突发性的大规模并行处理数据传送。
  - 缺点：频繁建立物理通路时间开销大。

- 包交换

  - 存储转发：最简单的分组交换方式。

    网络时延与源和目的地之间的距离（跳数）成正比$T_{SF} = \frac{L}{B}(D+1)$

    - 优点：简单。
    - 缺点：包缓冲区大、网络时延大。

  - 虚拟直通路：对存储转发方式的一种改进，减少了网络时延

    通信时延$T=\frac{L+L_h \times(D+1)}{B} \approx \frac{L}{B}$

    - 优点：通信时延与结点数无关。
    - 缺点：中间结点依然需要缓冲器、寻径阻塞时依然需要存储整个包，占用缓冲区大。

  - 虫蚀：最小单位为片。一个结点把头片送到下一个结点后，后面的各片才能依次送出。

    通信时延$T_{WH}=T_f\times D+\frac{L}{B}=\frac{L+L_f\times D}{B} \approx \frac{L}{B}$

    - 优点：每个结点缓冲器小，易于 VLSI 实现。有较小的网络传输延迟。
    - 缺点：一片被阻塞时，该消息所有片都被阻塞在结点。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132137228.jpg" alt="9cff6c21c76dccfd344483e63a58f3e" style="zoom:33%;" />

**虚拟通道**：两个结点间的逻辑链接，它由源结点的片缓冲区、结点间的物理通道以及接收结点的片缓冲区组成。

缓冲区或通道上的循环等待会引起**死锁**，利用虚拟通道可以避免一些死锁。

包冲突的4种解决：

1. 把第二个包暂存在缓冲区
2. 阻塞第二个包
3. 丢弃第二个包
4. 绕道

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406132138165.png" alt="img" style="zoom: 33%;" />

**确定性寻径**：通信路径完全由源结点地址和目的地址来决定，也就是说，寻径路径是预先唯一地确定好了的，而与网络的状况无关。

**自适应寻径**：通信的通路每一次都要根据资源或者网络的情况来选择。

对于一个多维网来说，**维序寻径**要求对后继通道的选择是按照各维的顺序来进行的。二维叫 X-Y 寻径，超立方体叫 E-cube 寻径。

- 单播：对应于一对一的通信情况，即一个源结点发送消息到一个目的结点。
- 选播：对应于一到多的通信情况，即一个源结点发送同一消息到多个目的结点。
- 广播：对应于一到全体的通信情况，即一个源结点发送同一消息到全部结点。
- 会议：对应于多到多的通信情况。
- **通道流量**可用传输有关消息所使用的通道数来表示。
- **通信时延**则用包的最大传输时间来表示。

### 第10章 多处理机

#### MIMD计算机分类

根据存储器组织结构分类：

- **集中式共享存储器结构**（对称式共享存储器多处理机 SMP）

  最多由几十个处理器构成

  各处理器共享集中式物理存储器、通过总线或交换开关互连。

  也被称为 **UMA（Uniform Memory Access）结构**。各处理器访问存储器时延相同。

  最流行结构。

- **分布式存储器多处理机**：存储器分布在各结点。

  要求高带宽互连网络。

  优点：① 若大多数需求为本地访存，可以降低存储器、互连网络带宽需求。② 本地存储器访问时延小。

  缺点：① 处理器之间通信复杂。② 处理器之间访问延迟较大。

  **分布式多处理机的2种存储器系统结构**：

  1. 共享地址空间（每个结点存储器统一编址）：**分布式共享存储器系统 DSM**， 或**非均匀访存模型 NUMA**

     物理上分离的所有存储器作为一个统一的共享逻辑空间进行编址

     任何一个处理器可以访问共享空间中的任何一个单元（如果有访问权）

     不同处理器上的同一个物理地址指向的是同一个存储单元

  2. 独立地址空间（编址相互独立）：多存在于机群 COW

     系统地址空间由多个独立地址空间组成。

     每个结点存储器只能本地存储器访问。

     每个存储器-处理器模块是一台单独计算机

并行处理的挑战：

1. 程序中的并行性有限（Amdahl 定律导致加速比不高）

   解决：采用并行性更好的算法

2. 通信开销较大

   解决：依靠系统结构支持使远程访问延迟降低、改进编程技术。

==计算有远程访问的机器实际CPI==，$CPI=\text{基本}CPI + \text{远程访问率} \times \text{远程访问时钟周期数}$

反应并行程序性能的重要度量：$\frac{并行程序的计算}{通信比率}$。正相关于数据规模，负相关于处理器数目。

==作业题==

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141430917.png" alt="image-20240614143024729" style="zoom: 80%;" />

#### Cache一致性问题

允许共享数据进入Cache，就可能出现多个处理器中Cache中都有同一存储块的副本，当其中某个处理器对其Cache中的数据进行修改后，就会使得其Cache中的数据与其他Cache中的数据不一致。

存储器一致性定义：对存储器中某个数据项的任何读操作，均能得到其最新写入的值。满足以下三点：

- 处理器 P 对单元 X 进行一次写之后又对单元 X 进行读，读和写之间没有其它处理器对单元 X 进行写，则 P 读到的值总是前面写进去的值。
- 处理器 P 对单元 X 进行写之后，另一处理器 Q 对单元 X 进行读，读和写之间无其它写，则 Q 读到的值应为 P 写进去的值。
- **写串行化**：对同一单元的写是串行化的，即任意两个处理器对同一单元的两次写，从各个处理器的角度看来顺序都是相同的。

**Cache一致性协议**：在多个处理器中用来维护一致性的协议

- **目录式协议**（互连网络）

  物理存储器中对数据块的共享状态被保存在一个称为目录的地方

- **监听式协议**（总线）

  Cache 除了包含物理存储器中数据块的拷贝，也保存各个块的共享状态信息。

  Cache 通常连在共享存储器的总线上。当某个 Cache 需要访问存储器时，它把请求放到总线上广播出去。其他 Cache 控制器监听总线，判断它们自身是否有请求的数据块。如果有就进行相应操作。

**写作废**：在处理器对某个数据项写入之前，**作废其他副本**，保证它拥有对该数据项的**唯一访问权**。

**写更新**：当处理器对某数据想进行写入时，通过**广播更新其他 Cache** 中所有该数据的副本。

性能区别：

* 写作废是针对 Cache 块进行操作，而写更新则是针对字（或字节）进行

- 写作废消耗的总线和存储器带宽更少，多在基于总线的多处理机中采用。
- 写更新的延迟时间较小，适合在处理器个数不多时采用。

#### 监听协议的基本实现

3个关键方面

1. 处理器之间通过可以广播的互连机制（通常是总线）相连。
2. 一个处理器的 Cache 相应本地 CPU 访问时，如果涉及全局操作，Cache 控制器就要在总线上广播相应消息。
3. 所有处理器一直监听总线，检测总线上的地址在他们的 Cache 中是否有副本，若有，则相应该消息，并进行相应操作。

Cache 发送的消息：

1. RdMiss——读不命中：需要通过总线找到相应数据块的最新副本，调入本地 Cache。
2. WtMiss——写不命中：需要通过总线找到相应数据块的最新副本，调入本地 Cache。
   * 写直达法：从主存中总可以取到最新值。
   * **写回法**：最新值可能在某 Cache 中，也可能在主存中。（后续只讨论写回法）

监听的通常是 Cache 的标识（tag）。

给每个 Cache 块增设一个共享位：为“1”：该块是被多个处理器所共享；为“0”：仅被某个处理器所独占。

**块的拥有者**：拥有该数据块的唯一副本的处理器。

3种状态：

1. 无效（I）：Cache中该块的内容无效
2. 共享（S）：该块可能处于共享状态（多个存储器中都有副本）
3. 已修改（M）：该块已被修改过，并且还没写入存储器（块中内容是唯一最新的副本）

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141406500.png" alt="img" style="zoom: 50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141410958.png" alt="img" style="zoom:50%;" />

---

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141413446.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141413451.png" alt="img" style="zoom:50%;" />



<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141413438.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406142119568.png" alt="image-20240614211916368" style="zoom: 80%;" />



#### 目录协议的基本思想与实现

主存中设置一个**目录表**，存放每个数据块（行）状态位和若干指针位（构成一个位向量），指针位对应处理机 Cache 。

**状态位**指示数据块状态，指针位指出哪些处理机 Cache 中有数据块副本。

当一个处理机访问本身 Cache 时，根据目录表，有选择地通知存有数据块的处理机 Cache。避免 Cache 的不一致性。

**位向量**：记录哪些 Cache 中有副本，称为共享集 S。

存储块的状态有三种：

1. **未缓冲**：尚未调入 Cache。所有存储器 Cache 中都没有。

2. **共享**：**一个或多个**处理机拥有该块副本，且**副本与存储器中的该块相同。**

3. **独占**：仅一个处理机有该块副本，且该处理机已经进行了写操作。存储器中该块数据已过时。这个处理机称为该块拥有者。

三种结点：

1. 本地结点 A：发出访问请求的结点，假设访问的地址为 K。

2. 宿主结点 B：包含所访问的存储单元及其目录项的结点 。

3. 远程结点 C：拥有存储块副本的结点。可以和宿主结点是同一个结点，也可以不是。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141418639.png" alt="img" style="zoom: 33%;" />

结点间发送的消息：

- 本地结点发送给宿主结点（目录）的消息：
  - RdMiss（P，K）：处理机 P 读地址 k 数据未命中，请求宿主提供该块，并把 P 加入共享集。
  - WtMiss（P，k）：处理机 P 写地址 k 数据未命中，请求宿主提供该块，并把 P 设为该块独占者。
  - Invalidate（k）：向所有拥有相应数据块副本的远程 Cache 发送消息，作废副本。
- 宿主结点发送给本地结点消息：
  - DReply（D）：把数据 D 返回给本地 Cache。
  - Invalidate（k）：作废远程 Cache 中地址 k 的数据块。
  - Fetch（k）：从远程 Cache 取地址 k 数据到宿主结点，并把地址 k 块状态改为共享。
  - Fetch&Invalidate（k）：从远程 Cache 取地址 k 数据到宿主结点，并作废远程 Cache 中该块。
- 远程结点发给宿主结点的消息：
  - WtBack（k，D）：把远程 Cache 中地址 k 数据块 D 写回到宿主结点。这是对 Fetch 或 Fetch&Invalidate 的响应。

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141420290.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141420299.png" alt="img" style="zoom:50%;" />

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141420309.png" alt="img" style="zoom:50%;" />

##### 目录三类结构：

- 全映像目录：最大。

  - 每个目录项包含 N位位向量，对应处理机个数。
  - 优点：① 处理比较简单、速度快。② 每个 Cache 允许存放同一数据块的副本。
  - 缺点：① 存储空间开销大。② 目录空间复杂度O(N^2^)。③ 可扩放性很差。

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141423516.png" alt="img" style="zoom:33%;" />

- 有限映像目录：较大。

  - 优点：提高可扩放性，减少目录占用空间。
  - 核心思想：采用位数固定的目录项目。限制同一数据块在所有 Cache 中的副本总数。
  - 缺点：当目录项中 m 个指针占满，而又需要新调入该块时，就需要在 m 个指针中选择一个废弃。

  <img src="https://static.xqmmcqs.com/2022-06-09-13-01-14-zbli7U.png" alt="img" style="zoom:33%;" />

- 链式目录：最小。

  - 用一个目录指针链表表示共享集合。主存只有一个指针位指向一个处理机 Cache。

  - 优点：不限制副本个数，扩展性好。

  <img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141422583.png" alt="img" style="zoom:33%;" />

### 第13章 阵列处理机

#### 概念

操作模型用五元组表示：阵列处理机=$(N,C,I,M,R)$，$N$ 为处理单元 PE 数、$C$ 为控制部件 CU 直接执行的指令集、$I$ 为 CU 广播至所有 PE 并行执行的指令集、$M$ 为屏蔽方案集、$R$ 为数据寻径功能集。

#### 类 BSP 机存储体分配

讨论一台含 N 个 AE 和 M 个存储体的类 BSP 机的情况。

- 先将二维数组按列优先或者按行优先的顺序变换为一维数组，以形成一个一维线性地址空间，地址用 A 表示。
- 然后将地址 A 变换成并行存储器地址 $(i,j)$。其中$j$ 是存储体体号，$j=A(modM)$，$i$ 是在相应存储体内的地址，$i=\lfloor \frac{A}{N} \rfloor$。存储体的个数 M 是一个质数。

**例题**

<img src="https://yangchen-1318434888.cos.ap-beijing.myqcloud.com/images/202406141443840.png" alt="img" style="zoom:33%;" />

